{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quantum computation is an inherently noisy process. Scalable quantum computers will require fault-tolerance to implement useful computation. There are many proposed approaches to this, but one promising candidate is the family of topological quantum error correcting codes .","title":"About"},{"location":"setup/","text":"Setup 0. Getting setup with git version control and running bash scripts. It may be worthwhile for Windows users to install a github for windows , which should come with Git Shell. If you are a Mac user, you might need XCode's Command Line Package which allows for command line development in OSX. Note: you do not need the XCode app to get these developer tools. In order to install the package, run xcode-select --install in your terminal. If you get an error, you can troubleshoot and learn more about the package here . 1. Cloning the Repo Run git clone https://github.com/yaleqc/qiskit_topological_codes.git to clone this repo. 2. Install Miniconda (optional, but highly recommended) As with many projects, it may be useful to set up a package manager and environment manager. Miniconda is a free, minimal installer for conda which servers as both a package and environment manager! You don't have to use miniconda, but we highly recommend it. Follow these instructions for your operating system. Then, you should be able to run conda -h in your bash shell successfully. If this doesn't work, make sure to add miniconda to your path . 3. Set up conda environment Once you are able to successfully run conda -h , you can cd (change directory) into the directory into which you just cloned the qiskit topological code project. Then, run conda env create --file dependencies/requirements.yml to install all necessary dependencies and create an environment called qiskit-topological-codes-env using which you can test and develop the qiskit topological codes package! Note: The alternative is for you to install dependencies (python packages) manually until you are able to smoothly run the tutorials in this repo. 4. Run the tutorials Next, just activate your environment using conda activate qiskit-topological-codes-env , cd into the project repo directory, and run jupyter lab . Then, you should be able to open up the tutorial notebooks and run them without issues.","title":"Setup"},{"location":"setup/#setup","text":"","title":"Setup"},{"location":"setup/#0-getting-setup-with-git-version-control-and-running-bash-scripts","text":"It may be worthwhile for Windows users to install a github for windows , which should come with Git Shell. If you are a Mac user, you might need XCode's Command Line Package which allows for command line development in OSX. Note: you do not need the XCode app to get these developer tools. In order to install the package, run xcode-select --install in your terminal. If you get an error, you can troubleshoot and learn more about the package here .","title":"0. Getting setup with git version control and running bash scripts."},{"location":"setup/#1-cloning-the-repo","text":"Run git clone https://github.com/yaleqc/qiskit_topological_codes.git to clone this repo.","title":"1. Cloning the Repo"},{"location":"setup/#2-install-miniconda-optional-but-highly-recommended","text":"As with many projects, it may be useful to set up a package manager and environment manager. Miniconda is a free, minimal installer for conda which servers as both a package and environment manager! You don't have to use miniconda, but we highly recommend it. Follow these instructions for your operating system. Then, you should be able to run conda -h in your bash shell successfully. If this doesn't work, make sure to add miniconda to your path .","title":"2. Install Miniconda (optional, but highly recommended)"},{"location":"setup/#3-set-up-conda-environment","text":"Once you are able to successfully run conda -h , you can cd (change directory) into the directory into which you just cloned the qiskit topological code project. Then, run conda env create --file dependencies/requirements.yml to install all necessary dependencies and create an environment called qiskit-topological-codes-env using which you can test and develop the qiskit topological codes package! Note: The alternative is for you to install dependencies (python packages) manually until you are able to smoothly run the tutorials in this repo.","title":"3. Set up conda environment"},{"location":"setup/#4-run-the-tutorials","text":"Next, just activate your environment using conda activate qiskit-topological-codes-env , cd into the project repo directory, and run jupyter lab . Then, you should be able to open up the tutorial notebooks and run them without issues.","title":"4. Run the tutorials"},{"location":"reference/summary/","text":"qtcodes circuits base circ qubit_types repetition rotated_surface xxzz xzzx common constants fitters base lattice_decoder repetition rotated_surface tools benchmarking","title":"Summary"},{"location":"reference/qtcodes/","text":"Quantum Topological Codes (qtcodes) Package circuits special Topological Circuit Encoders base Base Topological Encoder Classes LatticeError ( Exception ) Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\" TopologicalQubit ( Generic ) A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) lattice_type property readonly Subclass of _TopologicalLattice __init__ ( self , params = None , name = 'tq' , circ = None ) special Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) draw ( self , ** kwargs ) Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () id_data ( self ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () parse_readout ( self , readout_string , readout_type = None ) Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" x ( self ) Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () x_c_if ( self , classical , val ) Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) z ( self ) Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () z_c_if ( self , classical , val ) Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) circ Topological Circuit and Register TopologicalCircuit TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ () cx ( self , control , target , ancilla_ctype = None , ancilla_params = None ) CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) draw ( self , ** kwargs ) Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self , tqubit ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () id_data ( self , tqubit ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () measure_lattice_x ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () measure_lattice_z ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () measure_x ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) measure_z ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) parse_readout ( self , tqubit , readout_string , readout_type = 'Z' ) Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) reset_x ( self , tqubit ) Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () reset_z ( self , tqubit ) Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () stabilize ( self , tqubit ) Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () x ( self , tqubit ) Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () z ( self , tqubit ) Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () TopologicalRegister A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __getitem__ ( self , key ) special Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __init__ ( self , circ = None , ctypes = None , params = None , name = 'treg' ) special Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) add_tqubit ( self , sub_register , ctype , params ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 add_tqubits ( self , sub_register , ctypes = None , params = None ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) qubit_types Qubit Types repetition Repetition Code Encoder Classes RepetitionQubit ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params rotated_surface Rotated Surface Code Encoder Classes RotatedQubit ( TopologicalQubit ) A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier () xxzz XXZZ Surface Code Encoder Classes XXZZQubit ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () xzzx XZZX Surface Code Encoder Classes XZZXQubit ( RotatedQubit ) A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () common special Common Constants, Utils constants Constants fitters special Topological Decoders base Base Topological Decoder Classes TopologicalDecoder ( Generic ) Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) encoder_type : Type property readonly TopologicalQubit correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" correct_readout_look_up_table ( self , syndromes , logical_readout_type ) Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) parse_readout ( self , readout_string ) Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" reset_look_up_table ( self ) Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } set_look_up_table ( self , logical_readout_type , logical_qubit_value , results ) Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) lattice_decoder Graph decoder for surface codes LatticeDecoder ( TopologicalDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () syndrome_graph_keys : List [ str ] property readonly List[str] of syndrome graph keys (e.g. \"X\", \"Z\") correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value draw ( self , graph , dpi = None , node_size = None , font_size = None , show = True ) Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) draw3D ( self , graph , angle = None ) Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () parse_readout ( self , readout_string , readout_type = None ) Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) repetition Graph decoder for rep code RepetitionDecoder ( RotatedDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation () encoder_type ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params rotated_surface Graph decoder for surface codes RotatedDecoder ( LatticeDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" ) encoder_type ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () tools special Benchmarking Module for Topological Codes benchmarking benchmarking class for qtcodes TopologicalBenchmark Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], ) logical_error_rate ( self , readout_strings , err_prob = None ) Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count single ( self , physical_error_rate , save_data = True , shots = 2048 ) Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value sweep ( self , physical_error_rates = None , save_data = True , shots = 2048 , deg_weight = True ) Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] sweep_mp ( self , physical_error_rates = None , save_data = True , shots = 2048 ) Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"qtcodes"},{"location":"reference/qtcodes/#qtcodes.circuits","text":"Topological Circuit Encoders","title":"circuits"},{"location":"reference/qtcodes/#qtcodes.circuits.base","text":"Base Topological Encoder Classes","title":"base"},{"location":"reference/qtcodes/#qtcodes.circuits.base.LatticeError","text":"Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\"","title":"LatticeError"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit","text":"A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"TopologicalQubit"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.lattice_type","text":"Subclass of _TopologicalLattice","title":"lattice_type"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.__init__","text":"Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ","title":"__init__()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target )","title":"cx()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.draw","text":"Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier ()","title":"id()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier ()","title":"id_data()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.parse_readout","text":"Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.readout_x","text":"Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg )","title":"readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.readout_z","text":"Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg )","title":"readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\"","title":"stabilize()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.x","text":"Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x ()","title":"x()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.x_c_if","text":"Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val )","title":"x_c_if()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.z","text":"Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z ()","title":"z()"},{"location":"reference/qtcodes/#qtcodes.circuits.base.TopologicalQubit.z_c_if","text":"Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val )","title":"z_c_if()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ","text":"Topological Circuit and Register","title":"circ"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit","text":"TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ ()","title":"TopologicalCircuit"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.cx","text":"CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 )","title":"cx()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.draw","text":"Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id ()","title":"id()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data ()","title":"id_data()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x ()","title":"measure_lattice_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z ()","title":"measure_lattice_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.measure_x","text":"Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg )","title":"measure_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.measure_z","text":"Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg )","title":"measure_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.parse_readout","text":"Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.reset_x","text":"Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.reset_z","text":"Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.stabilize","text":"Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize ()","title":"stabilize()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.x","text":"Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x ()","title":"x()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalCircuit.z","text":"Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z ()","title":"z()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalRegister","text":"A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"TopologicalRegister"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalRegister.__getitem__","text":"Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"__getitem__()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalRegister.__init__","text":"Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params )","title":"__init__()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalRegister.add_tqubit","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1","title":"add_tqubit()"},{"location":"reference/qtcodes/#qtcodes.circuits.circ.TopologicalRegister.add_tqubits","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ])","title":"add_tqubits()"},{"location":"reference/qtcodes/#qtcodes.circuits.qubit_types","text":"Qubit Types","title":"qubit_types"},{"location":"reference/qtcodes/#qtcodes.circuits.repetition","text":"Repetition Code Encoder Classes","title":"repetition"},{"location":"reference/qtcodes/#qtcodes.circuits.repetition.RepetitionQubit","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"RepetitionQubit"},{"location":"reference/qtcodes/#qtcodes.circuits.rotated_surface","text":"Rotated Surface Code Encoder Classes","title":"rotated_surface"},{"location":"reference/qtcodes/#qtcodes.circuits.rotated_surface.RotatedQubit","text":"A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"RotatedQubit"},{"location":"reference/qtcodes/#qtcodes.circuits.rotated_surface.RotatedQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"stabilize()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz","text":"XXZZ Surface Code Encoder Classes","title":"xxzz"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"XXZZQubit"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx","text":"XZZX Surface Code Encoder Classes","title":"xzzx"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit","text":"A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice","title":"XZZXQubit"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+>","title":"reset_x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+>","title":"reset_z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/#qtcodes.common","text":"Common Constants, Utils","title":"common"},{"location":"reference/qtcodes/#qtcodes.common.constants","text":"Constants","title":"constants"},{"location":"reference/qtcodes/#qtcodes.fitters","text":"Topological Decoders","title":"fitters"},{"location":"reference/qtcodes/#qtcodes.fitters.base","text":"Base Topological Decoder Classes","title":"base"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder","text":"Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"TopologicalDecoder"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.encoder_type","text":"TopologicalQubit","title":"encoder_type"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\"","title":"correct_readout()"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.correct_readout_look_up_table","text":"Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"correct_readout_look_up_table()"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.parse_readout","text":"Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\"","title":"parse_readout()"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.reset_look_up_table","text":"Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, }","title":"reset_look_up_table()"},{"location":"reference/qtcodes/#qtcodes.fitters.base.TopologicalDecoder.set_look_up_table","text":"Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () )","title":"set_look_up_table()"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder","text":"Graph decoder for surface codes","title":"lattice_decoder"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"LatticeDecoder"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder.syndrome_graph_keys","text":"List[str] of syndrome graph keys (e.g. \"X\", \"Z\")","title":"syndrome_graph_keys"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value","title":"correct_readout()"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw","text":"Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax )","title":"draw()"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw3D","text":"Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"draw3D()"},{"location":"reference/qtcodes/#qtcodes.fitters.lattice_decoder.LatticeDecoder.parse_readout","text":"Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/#qtcodes.fitters.repetition","text":"Graph decoder for rep code","title":"repetition"},{"location":"reference/qtcodes/#qtcodes.fitters.repetition.RepetitionDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation ()","title":"RepetitionDecoder"},{"location":"reference/qtcodes/#qtcodes.fitters.repetition.RepetitionDecoder.encoder_type","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"encoder_type"},{"location":"reference/qtcodes/#qtcodes.fitters.rotated_surface","text":"Graph decoder for surface codes","title":"rotated_surface"},{"location":"reference/qtcodes/#qtcodes.fitters.rotated_surface.RotatedDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" )","title":"RotatedDecoder"},{"location":"reference/qtcodes/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"encoder_type"},{"location":"reference/qtcodes/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/#qtcodes.tools","text":"Benchmarking Module for Topological Codes","title":"tools"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking","text":"benchmarking class for qtcodes","title":"benchmarking"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking.TopologicalBenchmark","text":"Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], )","title":"TopologicalBenchmark"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking.TopologicalBenchmark.logical_error_rate","text":"Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count","title":"logical_error_rate()"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking.TopologicalBenchmark.single","text":"Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value","title":"single()"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep","text":"Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ]","title":"sweep()"},{"location":"reference/qtcodes/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep_mp","text":"Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"sweep_mp()"},{"location":"reference/qtcodes/circuits/","text":"Topological Circuit Encoders base Base Topological Encoder Classes LatticeError ( Exception ) Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\" TopologicalQubit ( Generic ) A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) lattice_type property readonly Subclass of _TopologicalLattice __init__ ( self , params = None , name = 'tq' , circ = None ) special Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) draw ( self , ** kwargs ) Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () id_data ( self ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () parse_readout ( self , readout_string , readout_type = None ) Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" x ( self ) Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () x_c_if ( self , classical , val ) Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) z ( self ) Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () z_c_if ( self , classical , val ) Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) circ Topological Circuit and Register TopologicalCircuit TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ () cx ( self , control , target , ancilla_ctype = None , ancilla_params = None ) CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) draw ( self , ** kwargs ) Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self , tqubit ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () id_data ( self , tqubit ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () measure_lattice_x ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () measure_lattice_z ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () measure_x ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) measure_z ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) parse_readout ( self , tqubit , readout_string , readout_type = 'Z' ) Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) reset_x ( self , tqubit ) Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () reset_z ( self , tqubit ) Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () stabilize ( self , tqubit ) Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () x ( self , tqubit ) Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () z ( self , tqubit ) Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () TopologicalRegister A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __getitem__ ( self , key ) special Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __init__ ( self , circ = None , ctypes = None , params = None , name = 'treg' ) special Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) add_tqubit ( self , sub_register , ctype , params ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 add_tqubits ( self , sub_register , ctypes = None , params = None ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) qubit_types Qubit Types repetition Repetition Code Encoder Classes RepetitionQubit ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params rotated_surface Rotated Surface Code Encoder Classes RotatedQubit ( TopologicalQubit ) A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier () xxzz XXZZ Surface Code Encoder Classes XXZZQubit ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () xzzx XZZX Surface Code Encoder Classes XZZXQubit ( RotatedQubit ) A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"circuits"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base","text":"Base Topological Encoder Classes","title":"base"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.LatticeError","text":"Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\"","title":"LatticeError"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit","text":"A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"TopologicalQubit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.lattice_type","text":"Subclass of _TopologicalLattice","title":"lattice_type"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.__init__","text":"Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ","title":"__init__()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target )","title":"cx()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.draw","text":"Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier ()","title":"id()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier ()","title":"id_data()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.parse_readout","text":"Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.readout_x","text":"Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg )","title":"readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.readout_z","text":"Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg )","title":"readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\"","title":"stabilize()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.x","text":"Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x ()","title":"x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.x_c_if","text":"Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val )","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.z","text":"Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z ()","title":"z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.base.TopologicalQubit.z_c_if","text":"Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val )","title":"z_c_if()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ","text":"Topological Circuit and Register","title":"circ"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit","text":"TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ ()","title":"TopologicalCircuit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.cx","text":"CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 )","title":"cx()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.draw","text":"Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id ()","title":"id()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data ()","title":"id_data()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x ()","title":"measure_lattice_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z ()","title":"measure_lattice_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.measure_x","text":"Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg )","title":"measure_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.measure_z","text":"Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg )","title":"measure_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.parse_readout","text":"Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.reset_x","text":"Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.reset_z","text":"Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.stabilize","text":"Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize ()","title":"stabilize()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.x","text":"Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x ()","title":"x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalCircuit.z","text":"Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z ()","title":"z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalRegister","text":"A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"TopologicalRegister"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalRegister.__getitem__","text":"Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"__getitem__()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalRegister.__init__","text":"Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params )","title":"__init__()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalRegister.add_tqubit","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1","title":"add_tqubit()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.circ.TopologicalRegister.add_tqubits","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ])","title":"add_tqubits()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.qubit_types","text":"Qubit Types","title":"qubit_types"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.repetition","text":"Repetition Code Encoder Classes","title":"repetition"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.repetition.RepetitionQubit","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"RepetitionQubit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.rotated_surface","text":"Rotated Surface Code Encoder Classes","title":"rotated_surface"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.rotated_surface.RotatedQubit","text":"A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"RotatedQubit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.rotated_surface.RotatedQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"stabilize()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz","text":"XXZZ Surface Code Encoder Classes","title":"xxzz"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"XXZZQubit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx","text":"XZZX Surface Code Encoder Classes","title":"xzzx"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit","text":"A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice","title":"XZZXQubit"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+>","title":"reset_x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+>","title":"reset_z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/circuits/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/circuits/base/","text":"Base Topological Encoder Classes LatticeError ( Exception ) Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\" TopologicalQubit ( Generic ) A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) lattice_type property readonly Subclass of _TopologicalLattice __init__ ( self , params = None , name = 'tq' , circ = None ) special Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) draw ( self , ** kwargs ) Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () id_data ( self ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () parse_readout ( self , readout_string , readout_type = None ) Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type ) readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" x ( self ) Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () x_c_if ( self , classical , val ) Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) z ( self ) Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () z_c_if ( self , classical , val ) Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val )","title":"base"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.LatticeError","text":"Lattice Inconsistency Errors Source code in qtcodes/circuits/base.py class LatticeError ( Exception ): \"\"\" Lattice Inconsistency Errors \"\"\"","title":"LatticeError"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit","text":"A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. Source code in qtcodes/circuits/base.py class TopologicalQubit ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" A single topological code logical qubit. This stores a QuantumCircuit object onto which the topological circuit is built. This abstract class contains a list of abstract methods that should be implemented by subclasses. \"\"\" @property @abstractmethod def lattice_type ( self ): \"\"\" Subclass of _TopologicalLattice \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ) -> str : return self . circ . __str__ () @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier () def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier () def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x () def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z () def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x () def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val ) def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val ) def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg ) def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x () def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z () def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"TopologicalQubit"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.lattice_type","text":"Subclass of _TopologicalLattice","title":"lattice_type"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.__init__","text":"Initializes this Topological Qubit class. Parameters: Name Type Description Default params Dict[str,int] Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'tq' circ Optional[QuantumCircuit] QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None Source code in qtcodes/circuits/base.py def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : \"\"\" Initializes this Topological Qubit class. Args: params (Dict[str,int]): Contains params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. circ (Optional[QuantumCircuit]): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. \"\"\" # == None is necessary, as `not QuantumCircuit()` is True circ = QuantumCircuit () if circ is None else circ params = params if params else {} self . lattice : _TopologicalLattice = self . lattice_type ( params , name , circ ) self . name = name self . circ = circ","title":"__init__()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Additional Information: Exactly one of control or target must be provided. Source code in qtcodes/circuits/base.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit Additional Information: Exactly one of control or target must be provided. \"\"\" if not ( bool ( control ) ^ bool ( target )): raise ValueError ( \"Please specify exactly one of source or target\" ) self . lattice . cx ( control , target )","title":"cx()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.draw","text":"Convenience method to draw quantum circuit. Source code in qtcodes/circuits/base.py def draw ( self , ** kwargs ) -> None : \"\"\" Convenience method to draw quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id ( self ) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" for register in self . lattice . qregisters . values (): self . circ . id ( register ) self . circ . barrier ()","title":"id()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Source code in qtcodes/circuits/base.py def id_data ( self ) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. \"\"\" self . circ . id ( self . lattice . qregisters [ \"data\" ]) self . circ . barrier ()","title":"id_data()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/base.py def lattice_readout_x ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of X stabilizer measurments, as well as a logical X readout. \"\"\" self . lattice . lattice_readout_x ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/base.py def lattice_readout_z ( self ) -> None : \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of Z stabilizer measurments, as well as a logical Z readout. \"\"\" self . lattice . lattice_readout_z ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.parse_readout","text":"Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Source code in qtcodes/circuits/base.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Wrapper on helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. \"\"\" return self . lattice . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.readout_x","text":"Convenience method to read-out the logical-X projection. Source code in qtcodes/circuits/base.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-X projection. \"\"\" self . lattice . readout_x ( readout_creg = readout_creg )","title":"readout_x()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.readout_z","text":"Convenience method to read-out the logical-Z projection. Source code in qtcodes/circuits/base.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : \"\"\" Convenience method to read-out the logical-Z projection. \"\"\" self . lattice . readout_z ( readout_creg = readout_creg )","title":"readout_z()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/base.py def reset_x ( self ) -> None : \"\"\" Initialize/reset to a logical |x+> state. \"\"\" self . lattice . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/base.py def reset_z ( self ) -> None : \"\"\" Initialize/reset to a logical |z+> state. \"\"\" self . lattice . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/base.py @abstractmethod def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\"","title":"stabilize()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.x","text":"Logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x ( self ) -> None : \"\"\" Logical X operator on the topological qubit. \"\"\" self . lattice . x ()","title":"x()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.x_c_if","text":"Classical conditioned logical X operator on the topological qubit. Source code in qtcodes/circuits/base.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical X operator on the topological qubit. \"\"\" self . lattice . x_c_if ( classical , val )","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.z","text":"Logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z ( self ) -> None : \"\"\" Logical Z operator on the topological qubit. \"\"\" self . lattice . z ()","title":"z()"},{"location":"reference/qtcodes/circuits/base/#qtcodes.circuits.base.TopologicalQubit.z_c_if","text":"Classical conditioned logical Z operator on the topological qubit. Source code in qtcodes/circuits/base.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classical conditioned logical Z operator on the topological qubit. \"\"\" self . lattice . z_c_if ( classical , val )","title":"z_c_if()"},{"location":"reference/qtcodes/circuits/circ/","text":"Topological Circuit and Register TopologicalCircuit TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ () cx ( self , control , target , ancilla_ctype = None , ancilla_params = None ) CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) draw ( self , ** kwargs ) Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) id ( self , tqubit ) Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () id_data ( self , tqubit ) Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () measure_lattice_x ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () measure_lattice_z ( self , tqubit ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () measure_x ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) measure_z ( self , tqubit , readout_creg = None ) Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) parse_readout ( self , tqubit , readout_string , readout_type = 'Z' ) Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) reset_x ( self , tqubit ) Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () reset_z ( self , tqubit ) Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () stabilize ( self , tqubit ) Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () x ( self , tqubit ) Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () z ( self , tqubit ) Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () TopologicalRegister A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __getitem__ ( self , key ) special Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" ) __init__ ( self , circ = None , ctypes = None , params = None , name = 'treg' ) special Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) add_tqubit ( self , sub_register , ctype , params ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 add_tqubits ( self , sub_register , ctypes = None , params = None ) Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ])","title":"circ"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit","text":"TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. Source code in qtcodes/circuits/circ.py class TopologicalCircuit : \"\"\" TopologicalCircuit is like a QuantumCircuit built on Topological Qubits. Shares the same QuantumCircuit object created in TopologicalRegister. \"\"\" def __init__ ( self , treg : TopologicalRegister ): self . treg = treg self . qreg : Dict [ str , QuantumRegister ] = {} self . creg : Dict [ str , ClassicalRegister ] = {} self . circ = treg . circ def add_creg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . creg and not override : return creg = ClassicalRegister ( size = size , name = name , bits = bits ) self . creg [ name ] = creg self . circ . add_register ( creg ) def add_qreg ( self , size = None , name = None , bits = None , override : bool = False ) -> None : if name in self . qreg and not override : return qreg = QuantumRegister ( size = size , name = name , bits = bits ) self . qreg [ name ] = qreg self . circ . add_register ( qreg ) def _get_index ( self , tqubit : Union [ TopologicalQubit , int ]) -> TopologicalQubit : \"\"\" Takes in either a TopologicalQubit or an int, and returns a TopologicalQubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg Returns: tqubit (TopologicalQubit): Returns the corresponding TopologicalQubit from treg \"\"\" if isinstance ( tqubit , int ): tqubit = cast ( int , tqubit ) tqubit = self . treg [ tqubit ] tqubit = cast ( TopologicalQubit , tqubit ) return tqubit def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize () def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id () def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data () def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x () def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z () def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x () def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z () def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 ) def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg ) def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg ) def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x () def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z () def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type ) def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs ) def __str__ ( self ): return self . circ . __str__ ()","title":"TopologicalCircuit"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.cx","text":"CNOT operator on control and target topological qubit Parameters: Name Type Description Default control Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required target Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required ancilla_ctype Optional[str] Specifies the logical type of ancilla bit None ancilla_params Optional[Dict[str, int]] Specifies the parameters of the ancilla bit None Source code in qtcodes/circuits/circ.py def cx ( self , control : Union [ TopologicalQubit , int ], target : Union [ TopologicalQubit , int ], ancilla_ctype : Optional [ str ] = None , ancilla_params : Optional [ Dict [ str , int ]] = None , ): \"\"\" CNOT operator on control and target topological qubit Args: control (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg target (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg ancilla_ctype (Optional[str]): Specifies the logical type of ancilla bit ancilla_params (Optional[Dict[str, int]]): Specifies the parameters of the ancilla bit \"\"\" # default ctype and params if ( ancilla_ctype is not None ) ^ ( ancilla_params is not None ): raise ValueError ( \"Please provide both a ctype and params or neither to use the control qubit ctype and params by default.\" ) elif ancilla_ctype is None : control_q = self . _get_index ( control ) ancilla_ctype = type ( control_q ) . __name__ . replace ( \"Qubit\" , \"\" ) ancilla_params = control_q . lattice . params # get qubits control = self . _get_index ( control ) target = self . _get_index ( target ) if \"ancilla\" not in self . treg . tqubits : self . treg . add_tqubit ( \"ancilla\" , ancilla_ctype , ancilla_params ) ancilla = cast ( TopologicalQubit , list ( self . treg [ \"ancilla\" ] . values ())[ - 1 ]) # prepare bits self . add_creg ( 1 , \"m1\" ) self . add_creg ( 1 , \"m2\" ) self . add_creg ( 1 , \"m3\" ) # prepare ancilla ancilla . reset_x () # Z (control) x Z (ancilla) self . add_qreg ( 1 , \"cnot_readout\" ) readout = self . qreg [ \"cnot_readout\" ][ 0 ] # Z x Z self . circ . reset ( readout ) control . cx ( target = readout ) ancilla . cx ( target = readout ) self . circ . measure ( readout , self . creg [ \"m1\" ][ 0 ]) # X x X self . circ . reset ( readout ) self . circ . h ( readout ) target . cx ( control = readout ) ancilla . cx ( control = readout ) self . circ . h ( readout ) self . circ . measure ( readout , self . creg [ \"m2\" ][ 0 ]) # Z ancilla . readout_z ( readout_creg = self . creg [ \"m3\" ]) # classical conditioned control . z_c_if ( self . creg [ \"m2\" ], 1 ) target . x_c_if ( self . creg [ \"m1\" ], 1 ) target . x_c_if ( self . creg [ \"m3\" ], 1 )","title":"cx()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.draw","text":"Convenience method to draw underlying quantum circuit. Source code in qtcodes/circuits/circ.py def draw ( self , ** kwargs ): \"\"\" Convenience method to draw underlying quantum circuit. \"\"\" return self . circ . draw ( ** kwargs )","title":"draw()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.id","text":"Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data and syndrome qubits. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id ()","title":"id()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.id_data","text":"Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def id_data ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Inserts an identity on the data qubits only. This allows us to create an isolated noise model by inserting errors only on identity gates. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . id_data ()","title":"id_data()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_x ()","title":"measure_lattice_x()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.measure_lattice_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_lattice_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . lattice_readout_z ()","title":"measure_lattice_z()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.measure_x","text":"Convenience method to read-out the logical-X projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_x ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-X projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_x ( readout_creg = readout_creg )","title":"measure_x()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.measure_z","text":"Convenience method to read-out the logical-Z projection. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def measure_z ( self , tqubit : Union [ TopologicalQubit , int ], readout_creg : Optional [ ClassicalRegister ] = None , ): \"\"\" Convenience method to read-out the logical-Z projection. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . readout_z ( readout_creg = readout_creg )","title":"measure_z()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.parse_readout","text":"Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/circuits/circ.py def parse_readout ( self , tqubit : Union [ TopologicalQubit , int ], readout_string : str , readout_type : Optional [ str ] = \"Z\" , ) -> Tuple [ int , Dict [ str , List [ Any ]]]: \"\"\" Helper method to turn a result string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention, based on the topological qubit of choice. The implementation varies with different topological qubits, but here's an example from the rotated surface code: Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" tqubit = self . _get_index ( tqubit ) return tqubit . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.reset_x","text":"Initialize/reset to a logical |x+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_x ( self , tqubit : Union [ TopologicalQubit , int ]) -> None : \"\"\" Initialize/reset to a logical |x+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_x ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.reset_z","text":"Initialize/reset to a logical |z+> state on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def reset_z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Initialize/reset to a logical |z+> state on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . reset_z ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.stabilize","text":"Run a single round of stabilization (entangle and measure) on the tqubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def stabilize ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Run a single round of stabilization (entangle and measure) on the tqubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . stabilize ()","title":"stabilize()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.x","text":"Logical X operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def x ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical X operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . x ()","title":"x()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalCircuit.z","text":"Logical Z operator on the topological qubit. Parameters: Name Type Description Default tqubit Union[TopologicalQubit, int] Either already a TopologicalQubit or an int index in treg required Source code in qtcodes/circuits/circ.py def z ( self , tqubit : Union [ TopologicalQubit , int ]): \"\"\" Logical Z operator on the topological qubit. Args: tqubit (Union[TopologicalQubit, int]): Either already a TopologicalQubit or an int index in treg \"\"\" tqubit = self . _get_index ( tqubit ) tqubit . z ()","title":"z()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalRegister","text":"A blueprint for a TopologicalRegister that stores topological qubit(s) Source code in qtcodes/circuits/circ.py class TopologicalRegister : \"\"\" A blueprint for a TopologicalRegister that stores topological qubit(s) \"\"\" def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params ) def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ]) def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1 def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"TopologicalRegister"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalRegister.__getitem__","text":"Allows us to return the nth element of TopologicalRegister as a list. Source code in qtcodes/circuits/circ.py def __getitem__ ( self , key : Union [ str , int ]): \"\"\" Allows us to return the nth element of TopologicalRegister as a list. \"\"\" if isinstance ( key , str ): key = str ( key ) return self . tqubits [ key ] elif isinstance ( key , int ): key = int ( key ) for _ , sub_reg in self . tqubits . items (): if key in sub_reg : return sub_reg [ key ] raise ValueError ( \"Key not found!\" )","title":"__getitem__()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalRegister.__init__","text":"Parameters: Name Type Description Default circ QuantumCircuit QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. None ctypes List[str] Specifies the types of the TQubits being added None params List[Dict[str,int]] Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. None name str Useful when combining multiple TopologicalQubits together. Prepended to all registers. 'treg' Source code in qtcodes/circuits/circ.py def __init__ ( self , circ : QuantumCircuit = None , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , name : str = \"treg\" , ): \"\"\" Args: circ (QuantumCircuit): QuantumCircuit on top of which the topological qubit is built. This is often shared amongst multiple TQubits. If none is provided, then a new QuantumCircuit is initialized and stored. ctypes (List[str]): Specifies the types of the TQubits being added params (List[Dict[str,int]]): Contains a list of params such as d, where d is the number of physical \"data\" qubits lining a row or column of the lattice. name (str): Useful when combining multiple TopologicalQubits together. Prepended to all registers. \"\"\" ctypes = [] if ctypes is None else ctypes params = [] if params is None else params self . params = [] self . name = name self . n = 0 # == None is necessary, as \"not circ\" is true for circ=QuantumCircuit() self . circ = QuantumCircuit () if circ is None else circ self . tqubits : Dict [ str , Dict [ int , Type [ Any ]]] = {} self . add_tqubits ( \"data\" , ctypes , params )","title":"__init__()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalRegister.add_tqubit","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctype str Specifies the type of TQubit being added required params Dict[str, int] Specifies the params for the Tqubit being added required Source code in qtcodes/circuits/circ.py def add_tqubit ( self , sub_register : str , ctype : str , params : Dict [ str , int ]): \"\"\" Args: sub_register (str): Specifies the subregister ctype (str): Specifies the type of TQubit being added params (Dict[str, int]): Specifies the params for the Tqubit being added \"\"\" if sub_register not in self . tqubits : self . tqubits [ sub_register ] = {} self . tqubits [ sub_register ][ self . n ] = str2qtype [ ctype ]( params , name = self . name + \"_\" + str ( self . n ), circ = self . circ ) self . params . append ( params ) self . n += 1","title":"add_tqubit()"},{"location":"reference/qtcodes/circuits/circ/#qtcodes.circuits.circ.TopologicalRegister.add_tqubits","text":"Parameters: Name Type Description Default sub_register str Specifies the subregister required ctypes Optional[List[str]] (List[str]): Specifies the types of the TQubits being added None params Optional[List[Dict[str, int]]] (List[Dict[str, int]]): Contains a list of params for each TQubit being added None Source code in qtcodes/circuits/circ.py def add_tqubits ( self , sub_register : str , ctypes : Optional [ List [ str ]] = None , params : Optional [ List [ Dict [ str , int ]]] = None , ) -> None : \"\"\" Args: sub_register (str): Specifies the subregister ctypes: (List[str]): Specifies the types of the TQubits being added params: (List[Dict[str, int]]): Contains a list of params for each TQubit being added \"\"\" params = [] if params is None else params ctypes = [] if ctypes is None else ctypes if len ( params ) != len ( ctypes ): raise ValueError ( \"Please match the number of params with the number of Topological Qubits added: Current number of params - \" + str ( len ( params )) + \", Current number of Topological Qubits: \" + str ( len ( ctypes )) ) for i in range ( len ( ctypes )): if ctypes [ i ] not in str2qtype : raise ValueError ( \"Please choose a Topological Qubit type from: \" + str ( list ( str2qtype . keys ())) ) for i in range ( len ( ctypes )): self . add_tqubit ( sub_register , ctypes [ i ], params [ i ])","title":"add_tqubits()"},{"location":"reference/qtcodes/circuits/qubit_types/","text":"Qubit Types","title":"qubit_types"},{"location":"reference/qtcodes/circuits/repetition/","text":"Repetition Code Encoder Classes RepetitionQubit ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"repetition"},{"location":"reference/qtcodes/circuits/repetition/#qtcodes.circuits.repetition.RepetitionQubit","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/circuits/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"RepetitionQubit"},{"location":"reference/qtcodes/circuits/rotated_surface/","text":"Rotated Surface Code Encoder Classes RotatedQubit ( TopologicalQubit ) A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier () stabilize ( self ) Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"rotated_surface"},{"location":"reference/qtcodes/circuits/rotated_surface/#qtcodes.circuits.rotated_surface.RotatedQubit","text":"A single logical surface code qubit. Source code in qtcodes/circuits/rotated_surface.py class RotatedQubit ( TopologicalQubit [ TQubit ], metaclass = ABCMeta ): \"\"\" A single logical surface code qubit. \"\"\" def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"RotatedQubit"},{"location":"reference/qtcodes/circuits/rotated_surface/#qtcodes.circuits.rotated_surface.RotatedQubit.stabilize","text":"Run a single round of stabilization (entangle and measure). Source code in qtcodes/circuits/rotated_surface.py def stabilize ( self ) -> None : \"\"\" Run a single round of stabilization (entangle and measure). \"\"\" num_syn = self . lattice . params [ \"num_syn\" ] self . lattice . params [ \"T\" ] += 1 syndrome_readouts = ClassicalRegister ( num_syn [ self . lattice . SYNX ] + num_syn [ self . lattice . SYNZ ], name = self . name + \"_c {} \" . format ( self . lattice . params [ \"T\" ]), ) self . lattice . cregisters [ \"syndrome {} \" . format ( self . lattice . params [ \"T\" ]) ] = syndrome_readouts self . circ . add_register ( syndrome_readouts ) self . lattice . entangle () # measure syndromes if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mz\" ], syndrome_readouts [ 0 : num_syn [ self . lattice . SYNZ ]], ) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . measure ( self . lattice . qregisters [ \"mx\" ], syndrome_readouts [ num_syn [ self . lattice . SYNZ ] : num_syn [ self . lattice . SYNZ ] + num_syn [ self . lattice . SYNX ] ], ) if num_syn [ self . lattice . SYNZ ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mz\" ]) if num_syn [ self . lattice . SYNX ] > 0 : self . circ . reset ( self . lattice . qregisters [ \"mx\" ]) self . circ . barrier ()","title":"stabilize()"},{"location":"reference/qtcodes/circuits/xxzz/","text":"XXZZ Surface Code Encoder Classes XXZZQubit ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"xxzz"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/circuits/xxzz.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"XXZZQubit"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/circuits/xxzz.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xxzz.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xxzz.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xxzz.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_x()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xxzz.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_z()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xxzz.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xxzz.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xxzz.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/circuits/xxzz/#qtcodes.circuits.xxzz.XXZZQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xxzz.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/circuits/xzzx/","text":"XZZX Surface Code Encoder Classes XZZXQubit ( RotatedQubit ) A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"xzzx"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit","text":"A single, logical XZZX surface code qubit. Source code in qtcodes/circuits/xzzx.py class XZZXQubit ( RotatedQubit ): \"\"\" A single, logical XZZX surface code qubit. \"\"\" lattice_type = _XZZXLattice","title":"XZZXQubit"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. Source code in qtcodes/circuits/xzzx.py class _XZZXLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XZZX Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XZZX , \"mz\" : _XZZX } def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+> def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+> def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking left-most column data_qubit_indxs = list ( range ( 0 , int ( self . params [ \"num_data\" ]), int ( self . params [ \"d\" ][ 1 ])) ) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) # Taking top-most row data_qubit_indxs = list ( range ( self . params [ \"d\" ][ self . W ])) # X Readout x_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 0 ] self . circ . h ( self . qregisters [ \"ancilla\" ]) self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ x_readout_indxs ] ) self . circ . h ( self . qregisters [ \"ancilla\" ]) # Z Readout z_readout_indxs = [ i for i in data_qubit_indxs if i % 2 == 1 ] self . circ . cx ( self . qregisters [ \"data\" ][ z_readout_indxs ], self . qregisters [ \"ancilla\" ] ) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/circuits/xzzx.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) else : self . circ . cz ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for odd data qubits self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/circuits/xzzx.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> # add H to measure along X for even data qubits self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/circuits/xzzx.py def reset_x ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 1 :: 2 ]) # H|0> = |+>","title":"reset_x()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/circuits/xzzx.py def reset_z ( self ): self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ][ 0 :: 2 ]) # H|0> = |+>","title":"reset_z()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/circuits/xzzx.py def x ( self ) -> None : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/circuits/xzzx.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): if i % 2 == 1 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/circuits/xzzx.py def z ( self ) -> None : # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/circuits/xzzx/#qtcodes.circuits.xzzx.XZZXQubit.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/circuits/xzzx.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" # Taking top-most row for i in range ( self . params [ \"d\" ][ self . W ]): if i % 2 == 0 : self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) else : self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/common/","text":"Common Constants, Utils constants Constants","title":"common"},{"location":"reference/qtcodes/common/#qtcodes.common.constants","text":"Constants","title":"constants"},{"location":"reference/qtcodes/common/constants/","text":"Constants","title":"constants"},{"location":"reference/qtcodes/fitters/","text":"Topological Decoders base Base Topological Decoder Classes TopologicalDecoder ( Generic ) Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) encoder_type : Type property readonly TopologicalQubit correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" correct_readout_look_up_table ( self , syndromes , logical_readout_type ) Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) parse_readout ( self , readout_string ) Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" reset_look_up_table ( self ) Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } set_look_up_table ( self , logical_readout_type , logical_qubit_value , results ) Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) lattice_decoder Graph decoder for surface codes LatticeDecoder ( TopologicalDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () syndrome_graph_keys : List [ str ] property readonly List[str] of syndrome graph keys (e.g. \"X\", \"Z\") correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value draw ( self , graph , dpi = None , node_size = None , font_size = None , show = True ) Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) draw3D ( self , graph , angle = None ) Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () parse_readout ( self , readout_string , readout_type = None ) Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) repetition Graph decoder for rep code RepetitionDecoder ( RotatedDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation () encoder_type ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params rotated_surface Graph decoder for surface codes RotatedDecoder ( LatticeDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" ) encoder_type ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"fitters"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base","text":"Base Topological Decoder Classes","title":"base"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder","text":"Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"TopologicalDecoder"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.encoder_type","text":"TopologicalQubit","title":"encoder_type"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\"","title":"correct_readout()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.correct_readout_look_up_table","text":"Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"correct_readout_look_up_table()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.parse_readout","text":"Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\"","title":"parse_readout()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.reset_look_up_table","text":"Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, }","title":"reset_look_up_table()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.base.TopologicalDecoder.set_look_up_table","text":"Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () )","title":"set_look_up_table()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder","text":"Graph decoder for surface codes","title":"lattice_decoder"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"LatticeDecoder"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder.syndrome_graph_keys","text":"List[str] of syndrome graph keys (e.g. \"X\", \"Z\")","title":"syndrome_graph_keys"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value","title":"correct_readout()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw","text":"Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax )","title":"draw()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw3D","text":"Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"draw3D()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.lattice_decoder.LatticeDecoder.parse_readout","text":"Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.repetition","text":"Graph decoder for rep code","title":"repetition"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.repetition.RepetitionDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation ()","title":"RepetitionDecoder"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.repetition.RepetitionDecoder.encoder_type","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"encoder_type"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface","text":"Graph decoder for surface codes","title":"rotated_surface"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" )","title":"RotatedDecoder"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"encoder_type"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_x()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_z()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/fitters/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/fitters/base/","text":"Base Topological Decoder Classes TopologicalDecoder ( Generic ) Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) encoder_type : Type property readonly TopologicalQubit correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" correct_readout_look_up_table ( self , syndromes , logical_readout_type ) Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s )) parse_readout ( self , readout_string ) Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" reset_look_up_table ( self ) Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } set_look_up_table ( self , logical_readout_type , logical_qubit_value , results ) Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () )","title":"base"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder","text":"Abstract class for topological code MWPM decoders to implement. Source code in qtcodes/fitters/base.py class TopologicalDecoder ( Generic [ TQubit ], metaclass = ABCMeta ): \"\"\" Abstract class for topological code MWPM decoders to implement. \"\"\" @property @abstractmethod def encoder_type ( self ) -> Type : \"\"\" TopologicalQubit \"\"\" @abstractmethod def __init__ ( self , params : Dict ) -> None : self . S : Dict [ str , rx . PyGraph ] = {} self . node_map : Dict [ str , Dict [ TQubit , int ]] = {} self . params = params self . look_up_table : Dict [ str , Dict [ int , Dict [ str , int ]]] = {} self . look_up_table_shots : Dict [ str , Dict [ int , int ]] = {} self . reset_look_up_table () @abstractmethod def _make_syndrome_graph ( self ) -> None : \"\"\" Construct syndrome graphs used for MWPM decoding. \"\"\" @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\" @abstractmethod def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> rx . PyGraph : \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([TQubit,]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" @abstractmethod def _run_mwpm ( self , matching_graph : rx . PyGraph ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, } def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () ) def _run_look_up ( self , syndromes : str , logical_readout_type : str , p_i : Optional [ List [ float ]] = None , ) -> List [ float ]: \"\"\" Calculates conditional prob p(|i> | syndromes) by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" p_i (Optional[List[float]]): p_i[i] is the posterior probability that the logical qubit is |i> Returns: p_i_given_s (List[float]): p(i|s) conditional probability that given syndromes s, the qubit is in |i> \"\"\" p_s_given_i = [ 0.0 , 0.0 , ] # p_s_given_i[i] is the prob that syndromes s was produced by |i>, i.e. p(s|i) for log in [ 0 , 1 ]: if syndromes in self . look_up_table [ logical_readout_type ][ log ]: p_s_given_i [ log ] = ( self . look_up_table [ logical_readout_type ][ log ][ syndromes ] / self . look_up_table_shots [ logical_readout_type ][ log ] ) # posterior prob that the qubit in |i>, i.e. p(i) p_i = [ 1.0 / 2 , 1.0 / 2 ] if not p_i else p_i # p(s) = sum_i p(s|i)p(i) p_s = p_s_given_i [ 0 ] * p_i [ 0 ] + p_s_given_i [ 1 ] * p_i [ 1 ] # p(i|s) = p(s|i)p(i)/p(s), Bayes Rule p_i_given_s = [ p_s_given_i [ i ] * p_i [ i ] / p_s for i in [ 0 , 1 ]] return p_i_given_s def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"TopologicalDecoder"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.encoder_type","text":"TopologicalQubit","title":"encoder_type"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type (e.g. \"X\" or \"Z\") required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/base.py @abstractmethod def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key (str): syndrome type value (TQubit): syndrome node hits (changes between consecutive rounds) (str): readout string logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type (e.g. \"X\" or \"Z\") err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\"","title":"correct_readout()"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.correct_readout_look_up_table","text":"Calculates most likely logical_qubit_value by look up table decoding. Parameters: Name Type Description Default syndromes str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required logical_readout_type str \"X\" or \"Z\" required Returns: Type Description logical_qubit_value (int) most probable original logical qubit value from look up table decoding Source code in qtcodes/fitters/base.py def correct_readout_look_up_table ( self , syndromes : str , logical_readout_type : str ) -> int : \"\"\" Calculates most likely logical_qubit_value by look up table decoding. Args: syndromes (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) logical_readout_type (str): \"X\" or \"Z\" Returns: logical_qubit_value (int): most probable original logical qubit value from look up table decoding \"\"\" p_i_given_s = self . _run_look_up ( syndromes , logical_readout_type ) return p_i_given_s . index ( max ( p_i_given_s ))","title":"correct_readout_look_up_table()"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.parse_readout","text":"Converte between readout_string to logical_readout and syndrome nodes. Parameters: Name Type Description Default readout_string str readout string from quantum circuit required Returns: Type Description logical_readout (int) logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit Source code in qtcodes/fitters/base.py @abstractmethod def parse_readout ( self , readout_string : str ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converte between readout_string to logical_readout and syndrome nodes. Args: readout_string (str): readout string from quantum circuit Returns: logical_readout (int): logical readout value from readout syndromes (Dict): key (str): syndrome type key val (List[TQubit]): list of syndrome nodes hit \"\"\"","title":"parse_readout()"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.reset_look_up_table","text":"Empty look up table used to reset the self.look_up_table Returns: Type Description (Dict[str, Dict[int, Dict[str, int]]]) key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts Source code in qtcodes/fitters/base.py def reset_look_up_table ( self ) -> None : \"\"\" Empty look up table used to reset the self.look_up_table Returns: (Dict[str, Dict[int, Dict[str, int]]]): key (str): logical_readout_type val: key (int): logical_qubit_value val: key (str): readout_string val (int): counts (Dict[str, Dict[int, int]]): key (str): logical_readout_type val: key (int): logical_qubit_value val (int): total_counts \"\"\" self . look_up_table = { \"X\" : { 0 : {}, 1 : {}}, \"Z\" : { 0 : {}, 1 : {}}, } self . look_up_table_shots = { \"X\" : { 0 : 0 , 1 : 0 }, \"Z\" : { 0 : 0 , 1 : 0 }, }","title":"reset_look_up_table()"},{"location":"reference/qtcodes/fitters/base/#qtcodes.fitters.base.TopologicalDecoder.set_look_up_table","text":"Used to set look up table. Parameters: Name Type Description Default logical_readout_type str \"X\" or \"Z\" required logical_qubit_value int 0 or 1 required results Dict[str, int] key (str): readout_string val (int): counts required Source code in qtcodes/fitters/base.py def set_look_up_table ( self , logical_readout_type : str , logical_qubit_value : int , results : Dict [ str , int ], ): \"\"\" Used to set look up table. Args: logical_readout_type (str): \"X\" or \"Z\" logical_qubit_value (int): 0 or 1 results: key (str): readout_string val (int): counts \"\"\" self . look_up_table [ logical_readout_type ][ logical_qubit_value ] = results self . look_up_table_shots [ logical_readout_type ][ logical_qubit_value ] = sum ( results . values () )","title":"set_look_up_table()"},{"location":"reference/qtcodes/fitters/lattice_decoder/","text":"Graph decoder for surface codes LatticeDecoder ( TopologicalDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () syndrome_graph_keys : List [ str ] property readonly List[str] of syndrome graph keys (e.g. \"X\", \"Z\") correct_readout ( self , syndromes , logical_readout_type , logical_qubit_value = None , err_prob = None ) Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value draw ( self , graph , dpi = None , node_size = None , font_size = None , show = True ) Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) draw3D ( self , graph , angle = None ) Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show () parse_readout ( self , readout_string , readout_type = None ) Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type )","title":"lattice_decoder"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. Source code in qtcodes/fitters/lattice_decoder.py class LatticeDecoder ( TopologicalDecoder [ TQubit ], metaclass = ABCMeta ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction code, and then run suitable decoders. \"\"\" @property @abstractmethod def syndrome_graph_keys ( self ) -> List [ str ]: \"\"\" List[str] of syndrome graph keys (e.g. \"X\", \"Z\") \"\"\" def __init__ ( self , params : Dict ) -> None : super () . __init__ ( params ) self . _params_validation () for syndrome_graph_key in self . syndrome_graph_keys : self . S [ syndrome_graph_key ] = rx . PyGraph ( multigraph = False ) self . node_map [ syndrome_graph_key ] = {} self . virtual = self . _specify_virtual () self . _encoder = None self . _make_syndrome_graph () @property def encoder ( self ): if self . _encoder is None : self . _encoder = self . encoder_type ( self . params . copy ()) return self . _encoder def _params_validation ( self ): if \"d\" not in self . params or \"T\" not in self . params : raise ValueError ( \"Please include d and T in params.\" ) @abstractmethod def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" @abstractmethod def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): e.g. \"X\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" def _make_error_graph ( self , nodes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ): \"\"\"Creates error syndrome subgraph from list of syndrome nodes. The output of this function is a graph that's ready for minimum weight perfect matching (MWPM). If err_prob is specified, we adjust the shortest distance between syndrome nodes by the degeneracy of the error path. Args: nodes ([(t, x, y),]): List of changes of syndrome nodes in time. syndrome_graph_key (char): Which syndrome subgraph these nodes are from. err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_graph (rx.PyGraph): Nodes are syndromes, edges are proxy for error probabilities \"\"\" node_map : Dict [ TQubit , int ] = {} error_graph = rx . PyGraph ( multigraph = False ) # need to ensure there are an even number of nodes make_even = len ( nodes ) % 2 != 0 nodes += self . virtual [ syndrome_graph_key ] # add all nodes to error_graph for node in nodes : if node not in error_graph . nodes (): node_map [ node ] = error_graph . add_node ( node ) # Distance is proportional to the probability of this error chain, so # finding the maximum-weight perfect matching of the whole graph gives # the most likely sequence of errors that led to these syndromes. shortest_distance_mat = rx . graph_floyd_warshall_numpy ( self . S [ syndrome_graph_key ] ) num_shortest_paths : Dict [ int , Dict [ int , int ]] = {} for source , target in combinations ( nodes , 2 ): if ( source in self . virtual [ syndrome_graph_key ] and target in self . virtual [ syndrome_graph_key ] ): distance = 0.0 else : i = self . node_map [ syndrome_graph_key ][ source ] j = self . node_map [ syndrome_graph_key ][ target ] distance = float ( shortest_distance_mat [ i ][ j ]) if err_prob : deg , num_shortest_paths = self . _path_degeneracy ( source , target , syndrome_graph_key , num_shortest_paths , shortest_distance_mat , ) distance = distance - math . log ( deg ) / ( math . log1p ( - 1.0 * err_prob ) - math . log ( err_prob ) ) distance = - 1.0 * distance error_graph . add_edge ( node_map [ source ], node_map [ target ], distance ) if make_even : source = ( - 1 , - 1 , - 1 ) node_map [ source ] = error_graph . add_node ( source ) for target in self . virtual [ syndrome_graph_key ]: error_graph . add_edge ( node_map [ source ], node_map [ target ], 0 ) return error_graph def _path_degeneracy ( self , a : TQubit , b : TQubit , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], shortest_distance_mat : np . ndarray , ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\" Calculate the number of shortest error paths (degeneracy) that link two syndrome nodes through both space and time. If one of these nodes is virtual this will be stored in target, while the other non-virtual node will be stored in source. Then, the number of shortest error paths (degeneracy) from source to *any* virtual node, which is as equally close to source as source is to target, will be added together and returned as the total degeneracy. Args: a (tuple): Starting or ending syndrome node (degeneracy is symmetric) b (tuple): Ending or starting syndrome node (degeneracy is symmetric) syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. shortest_distance_mat: (np.ndarray): shortest_distance_mat[i][j] is the shortest path length between node indices i and j Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" a_indx = self . node_map [ syndrome_graph_key ][ a ] b_indx = self . node_map [ syndrome_graph_key ][ b ] source = None if a [ 0 ] == - 1 : target = a_indx # virtual source = b_indx elif b [ 0 ] == - 1 : target = b_indx # virtual source = a_indx if source : shortest_distance = shortest_distance_mat [ source ][ target ] virtual_nodes = self . virtual [ syndrome_graph_key ] total_deg = 0 for node in virtual_nodes : node_indx = self . node_map [ syndrome_graph_key ][ node ] if shortest_distance_mat [ source ][ node_indx ] == shortest_distance : deg , num_shortest_paths = self . _path_degeneracy_helper ( source , node_indx , syndrome_graph_key , num_shortest_paths ) total_deg += deg else : total_deg , num_shortest_paths = self . _path_degeneracy_helper ( a_indx , b_indx , syndrome_graph_key , num_shortest_paths ) return total_deg , num_shortest_paths def _path_degeneracy_helper ( self , a_indx : int , b_indx : int , syndrome_graph_key : str , num_shortest_paths : Dict [ int , Dict [ int , int ]], ) -> Tuple [ int , Dict [ int , Dict [ int , int ]]]: \"\"\"Helper to calculate the number of shortest error paths that link two syndrome nodes through both space and time. Args: a_indx (int): Indx of one node b_indx (int): Indx of another node syndrome_graph_key (str): specifies the syndrome graph (e.g. \"X\") num_shortest_paths (Dict[int, Dict[int, int]]): key: source node val: val[i] corresponds to number of shortest paths between source node (key) and target node i This saves some computations if already calculated. Returns: num (int): Number of degenerate shortest paths matching this syndrome pair num_shortest_paths (Dict[int, Dict[int, int]]]): updated num_shortest_paths \"\"\" if a_indx in num_shortest_paths . keys (): return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths elif b_indx in num_shortest_paths . keys (): return num_shortest_paths [ b_indx ][ a_indx ], num_shortest_paths else : num_shortest_paths [ a_indx ] = dict ( rx . num_shortest_paths_unweighted ( self . S [ syndrome_graph_key ], a_indx ) ) return num_shortest_paths [ a_indx ][ b_indx ], num_shortest_paths def _run_mwpm_graph ( self , matching_graph : rx . PyGraph , floats : bool = False ) -> rx . PyGraph : \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. This method is only to be used in tutorials to demo the matched graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: matched_graph (rx.PyGraph): matched graph without virtual-virtual matches \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) filtered_matches_idxs = [ ( i , j ) for ( i , j ) in matches_idxs if not ( matching_graph [ i ][ 0 ] == - 1 and matching_graph [ j ][ 0 ] == - 1 ) ] matched_graph = rx . PyGraph ( multigraph = False ) node_map = {} for i , j in filtered_matches_idxs : weight = matching_graph . get_edge_data ( i , j ) for node in [ i , j ]: if matching_graph [ node ] not in matched_graph . nodes (): node_map [ matching_graph [ node ]] = matched_graph . add_node ( matching_graph [ node ] ) matched_graph . add_edge ( node_map [ matching_graph [ i ]], node_map [ matching_graph [ j ]], weight ) return matched_graph def _run_mwpm ( self , matching_graph : rx . PyGraph , floats = False ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Return matches of minimum weight perfect matching (MWPM) on matching_graph. Args: matching_graph (rx.PyGraph): Graph to run MWPM. floats (bool): whether or not the graph contains float edge weights Returns: [(TQubit, TQubit),]: List of matchings found from MWPM \"\"\" # TODO: Temporary fix for matching with float edge weights weight_fn = int if not floats else lambda n : int ( n * 10000 ) matches_idxs = rx . max_weight_matching ( matching_graph , max_cardinality = True , weight_fn = weight_fn , ) matches = [( matching_graph [ i ], matching_graph [ j ]) for ( i , j ) in matches_idxs ] filtered_matches = [ ( source , target ) for ( source , target ) in matches if not ( source [ 0 ] == - 1 and target [ 0 ] == - 1 ) ] return filtered_matches def _corrections ( self , syndromes : List [ TQubit ], syndrome_graph_key : str , err_prob : Optional [ float ] = None , ) -> List [ Tuple [ TQubit , TQubit ]]: \"\"\" Args: syndromes ({str,[node,]}): key: syndrome_graph_key, e.g. \"X\", \"Z\" value: activated syndrome nodes (t,i,j) Dictionary with syndromes[\"X\"] containing tuples of the form (t,i,j) where t specifies time and (i,j) specify position of the X syndrome node changed from its value at (t-1,i,j), and similarly, syndromes[\"Z\"] for Z syndrome nodes. Returns: net_flips ({(i,j):np.ndarray}): dictionary with key representing physical (data) qubit and value representing the net error matrix on that data qubit. e.g. key: (0,0), value: [[0,1],[1,0]] (X error) Additional Information: This method can be used to correct readout errors as shown in self.correct_readout. \"\"\" if not syndromes : return [] error_graph = self . _make_error_graph ( syndromes , syndrome_graph_key , err_prob = err_prob ) matches = self . _run_mwpm ( error_graph , floats = err_prob is not None ) return matches def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type ) def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax ) def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"LatticeDecoder"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder.syndrome_graph_keys","text":"List[str] of syndrome graph keys (e.g. \"X\", \"Z\")","title":"syndrome_graph_keys"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder.correct_readout","text":"Parameters: Name Type Description Default syndromes Union[str, Dict[str, List[TQubit]]] either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. required logical_qubit_value Optional[int] measured logical qubit value None logical_readout_type str logical readout type out of \"X\" or \"Z\" required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description logical_qubit_value (int) The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. Source code in qtcodes/fitters/lattice_decoder.py def correct_readout ( self , syndromes : Union [ str , Dict [ str , List [ TQubit ]]], logical_readout_type : str , logical_qubit_value : Optional [ int ] = None , err_prob : Optional [ float ] = None , ) -> int : \"\"\" Args: syndromes (Union[str, Dict[str, List[TQubit]]]): either... (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) (str): string like \"1 00000000 00000000\" representing \"R S2 S1\" (d=3, T=2) where S1 is the first set of changed syndrome nodes (XOR'd with quiescent state syndrome measurements) S1 has the form: X3X2X1X0Z3Z2Z1Z0 in the case of d = 3. R represents the logical Z readout result. logical_qubit_value (Optional[int]): measured logical qubit value logical_readout_type (str): logical readout type out of \"X\" or \"Z\" err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: logical_qubit_value (int): The most probable encoded value of the logical qubit. Additional Information: This method can be used to benchmark logical error rates, as well as perform fault tolerant readout. \"\"\" if type ( syndromes ) == str : logical_qubit_value , syndromes = self . parse_readout ( str ( syndromes ), logical_readout_type ) syndromes = cast ( Dict [ str , List [ TQubit ]], syndromes ) logical_qubit_value = cast ( int , logical_qubit_value ) matches = self . _corrections ( syndromes [ logical_readout_type ], logical_readout_type , err_prob = err_prob ) for match in matches : if self . _is_crossing_readout_path ( match , logical_readout_type ): logical_qubit_value = ( logical_qubit_value + 1 ) % 2 return logical_qubit_value","title":"correct_readout()"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw","text":"Plots 2D graphs in IPython/Jupyter. Parameters: Name Type Description Default graph rx.PyGraph graph to be plotted required dpi int dpi used for Figure. Defaults to dynamically sized value based on node count. None node_size int size of node used for mpl_draw . Defaults to dynamically sized value based on node count. None font_size float font size used for mpl_draw . Defaults to dynamically sized value based on node count. None show bool whether to display the plot automatically. Defaults to True. True Returns: Type Description (figure, axes) A matplotlib Figure and Axes object Source code in qtcodes/fitters/lattice_decoder.py def draw ( self , graph : rx . PyGraph , dpi : Optional [ int ] = None , node_size : Optional [ int ] = None , font_size : Optional [ float ] = None , show : Optional [ bool ] = True , ) -> Tuple [ figure . Figure , axes . Axes ]: \"\"\" Plots 2D graphs in IPython/Jupyter. Args: graph (rx.PyGraph): graph to be plotted dpi (int): dpi used for Figure. Defaults to dynamically sized value based on node count. node_size (int): size of node used for `mpl_draw`. Defaults to dynamically sized value based on node count. font_size (float): font size used for `mpl_draw`. Defaults to dynamically sized value based on node count. show (bool): whether to display the plot automatically. Defaults to True. Returns: (figure, axes): A matplotlib Figure and Axes object \"\"\" if self . params [ \"T\" ] > 1 : self . draw3D ( graph ) return node_count = len ( graph . nodes ()) scale = 5 / ( math . sqrt ( node_count ) if node_count > 0 else 5 ) dpi = dpi if dpi is not None else 150 / scale node_size = node_size if node_size is not None else 1750 * scale font_size = font_size if font_size is not None else 6 * scale positions = {} for idx , node in enumerate ( graph . nodes ()): positions [ idx ] = [ node [ 2 ], - node [ 1 ]] fig = plt . figure ( dpi = dpi ) ax = fig . subplots () mpl_draw ( graph , ax = ax , with_labels = True , pos = positions , labels = str , edge_labels = lambda e : str ( np . around ( e , 3 )), node_size = node_size , node_color = \"lightblue\" , font_size = font_size , alpha = 0.8 , ) fig . tight_layout () if not show : plt . close ( fig ) return ( fig , ax )","title":"draw()"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder.draw3D","text":"Plots a graph with edge labels in 3D. Parameters: Name Type Description Default G rx.PyGraph Graph to be plotted in 3D. required angle [float, float] Initial 3D angle view. Defaults to [-116, 22] None Returns: Type Description None Plot is displayed in plt.show() Source code in qtcodes/fitters/lattice_decoder.py def draw3D ( self , graph : rx . PyGraph , angle : Optional [ List [ float ]] = None ) -> None : \"\"\"Plots a graph with edge labels in 3D. Args: G (rx.PyGraph): Graph to be plotted in 3D. angle ([float, float]): Initial 3D angle view. Defaults to [-116, 22] Returns: None: Plot is displayed in plt.show() \"\"\" angle = [ - 116 , 22 ] if not angle else angle # Define color range based on time colors = { node : plt . cm . plasma (( node [ 0 ] + 1 ) / self . params [ \"T\" ]) for node in graph . nodes () } def node_to_pos3D ( node ): z = ( self . params [ \"T\" ] - 1.0 ) / 2.0 if node [ 0 ] == - 1 else node [ 0 ] return node [ 2 ], - node [ 1 ], z # 3D network plot with plt . style . context (( \"ggplot\" )): fig = plt . figure ( figsize = ( 20 , 14 )) ax = Axes3D ( fig , auto_add_to_figure = False ) fig . add_axes ( ax ) # Loop on the nodes and look up in pos dictionary to extract the x,y,z coordinates of each node for node in graph . nodes (): xi , yi , zi = node_to_pos3D ( node ) # Scatter plot ax . scatter ( xi , yi , zi , color = colors [ node ], s = 120 * 1 , edgecolors = \"k\" , alpha = 0.7 , ) # Label node position ax . text ( xi , yi , zi , node , fontsize = 20 ) # Loop on the edges to get the x,y,z, coordinates of the connected nodes # Those two points are the extrema of the line to be plotted for src , tgt in graph . edge_list (): x_1 , y_1 , z_1 = node_to_pos3D ( graph [ src ]) x_2 , y_2 , z_2 = node_to_pos3D ( graph [ tgt ]) x_line = np . array (( x_1 , x_2 )) y_line = np . array (( y_1 , y_2 )) z_line = np . array (( z_1 , z_2 )) # Plot the connecting lines ax . plot ( x_line , y_line , z_line , color = \"black\" , alpha = 0.5 ) # Label edges at midpoints x_mid = ( x_1 + x_2 ) / 2 y_mid = ( y_1 + y_2 ) / 2 z_mid = ( z_1 + z_2 ) / 2 label = round ( graph . get_edge_data ( src , tgt ), 2 ) ax . text ( x_mid , y_mid , z_mid , label , fontsize = 14 ) # Set the initial view ax . view_init ( angle [ 1 ], angle [ 0 ]) # Hide the axes ax . set_axis_off () # Get rid of colored axes planes # First remove fill ax . xaxis . pane . fill = False ax . yaxis . pane . fill = False ax . zaxis . pane . fill = False # Now set color to white (or whatever is \"invisible\") ax . xaxis . pane . set_edgecolor ( \"w\" ) ax . yaxis . pane . set_edgecolor ( \"w\" ) ax . zaxis . pane . set_edgecolor ( \"w\" ) plt . show ()","title":"draw3D()"},{"location":"reference/qtcodes/fitters/lattice_decoder/#qtcodes.fitters.lattice_decoder.LatticeDecoder.parse_readout","text":"Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Parameters: Name Type Description Default readout_string str Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) required Returns: Type Description logical_readout (int) logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) Source code in qtcodes/fitters/lattice_decoder.py def parse_readout ( self , readout_string : str , readout_type : Optional [ str ] = None ) -> Tuple [ int , Dict [ str , List [ TQubit ]]]: \"\"\" Converts readout string to readout nodes. Turns a readout string (e.g. 1 10100000 10010000) into an appropriate logical readout value and XOR-ed syndrome locations according to our grid coordinate convention. Args: readout_string (str): Readout of the form \"0 00000000 00000000\" (logical_readout syndrome_1 syndrome_0) or of the form \"000000000 00000000 00000000\" (lattice_readout syndrome_1 syndrome_0) Returns: logical_readout (int): logical readout value syndromes (Dict[str, List[TQubit]]]): key: syndrome type value: (time, row, col) of parsed syndrome hits (changes between consecutive rounds) \"\"\" return self . encoder . parse_readout ( readout_string , readout_type )","title":"parse_readout()"},{"location":"reference/qtcodes/fitters/repetition/","text":"Graph decoder for rep code RepetitionDecoder ( RotatedDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation () encoder_type ( XXZZQubit ) A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"repetition"},{"location":"reference/qtcodes/fitters/repetition/#qtcodes.fitters.repetition.RepetitionDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. Source code in qtcodes/fitters/repetition.py class RepetitionDecoder ( RotatedDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction Repetition code, and then run suitable decoders. \"\"\" encoder_type = RepetitionQubit syndrome_graph_keys = [ \"Z\" ] def _params_validation ( self ): self . params = RepetitionQubit . _validate_params ( self . params ) if self . params [ \"phase-flip-protected\" ]: self . syndrome_graph_keys = [ \"X\" ] super () . _params_validation ()","title":"RepetitionDecoder"},{"location":"reference/qtcodes/fitters/repetition/#qtcodes.fitters.repetition.RepetitionDecoder.encoder_type","text":"A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. Source code in qtcodes/fitters/repetition.py class RepetitionQubit ( XXZZQubit ): \"\"\" A single logical repetition code qubit. At the physical level, this wraps a circuit, so we chose to subclass and extend TopologicalQubit which extends QuantumCircuit. \"\"\" def __init__ ( self , params : Optional [ Dict [ str , int ]] = None , name : str = \"tq\" , circ : Optional [ QuantumCircuit ] = None , ) -> None : params = self . _validate_params ( params ) super () . __init__ ( params , name , circ ) @staticmethod def _validate_params ( params : Optional [ Dict [ str , int ]]) -> Dict [ str , int ]: params = params if params else {} if \"phase-flip-protected\" not in params : params [ \"phase-flip-protected\" ] = False # The repetition code is a 1D lattice if \"d\" not in params : if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , 3 ) else : params [ \"d\" ] = ( 3 , 1 ) elif isinstance ( params [ \"d\" ], Number ): d = int ( params [ \"d\" ]) if params [ \"phase-flip-protected\" ]: params [ \"d\" ] = ( 1 , d ) else : params [ \"d\" ] = ( d , 1 ) elif isinstance ( params [ \"d\" ], Tuple ): if not params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DW ] != 1 : raise LatticeError ( \"Bit-flip protected repetition qubits can only have width 1 in parameter d: e.g. (3,1). If you \" + \"intend to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) if params [ \"phase-flip-protected\" ] and params [ \"d\" ][ constants . DH ] != 1 : raise LatticeError ( \"Phase-flip protected repetition qubits can only have height 1 in parameter d: e.g. (1,3). If you \" + \"intend to create a bit-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to False.\" ) else : raise LatticeError ( \"Please specify either an integer value (e.g. 3) or tuple (e.g. (3, 1)) for parameter d. If you intend \" + \"to create a phase-flip protected repetition qubit (e.g. with d=(1,3)), then please set the \" + \"phase-flip-protected flag parameter to True.\" ) return params","title":"encoder_type"},{"location":"reference/qtcodes/fitters/rotated_surface/","text":"Graph decoder for surface codes RotatedDecoder ( LatticeDecoder ) Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" ) encoder_type ( RotatedQubit ) A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice lattice_type ( _RotatedLattice ) This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () cx ( self , control = None , target = None ) Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) lattice_readout_x ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () lattice_readout_z ( self ) Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () readout_x ( self , readout_creg = None ) Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () readout_z ( self , readout_creg = None ) Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () reset_x ( self ) Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () reset_z ( self ) Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () x ( self ) Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () x_c_if ( self , classical , val ) Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () z ( self ) Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () z_c_if ( self , classical , val ) Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"rotated_surface"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder","text":"Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. Source code in qtcodes/fitters/rotated_surface.py class RotatedDecoder ( LatticeDecoder ): \"\"\" Class to construct the graph corresponding to the possible syndromes of a quantum error correction surface code, and then run suitable decoders. \"\"\" # TODO encoder is currently only used for string2node, # so we can use XXZZQubit, need to generalize encoder_type = XXZZQubit syndrome_graph_keys = [ \"X\" , \"Z\" ] def _params_validation ( self ): super () . _params_validation () # validation if isinstance ( self . params [ \"d\" ], Number ): d = int ( self . params [ \"d\" ]) self . params [ \"d\" ] = ( d , d ) if len ( self . params [ \"d\" ]) != 2 : raise LatticeError ( \"Please provide a code height and width in parameter d: e.g. (3,7).\" ) dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if dh % 2 != 1 : raise LatticeError ( \"Surface code height must be odd!\" ) if dw % 2 != 1 : raise LatticeError ( \"Surface code width must be odd!\" ) def _make_syndrome_graph ( self ) -> None : \"\"\" Populates self.S[\"X\"] and self.S[\"Z\"] syndrome rx.PyGraph's with nodes specified by time and position. Args: Returns: \"\"\" start_nodes = { \"Z\" : ( 0.5 , 0.5 ), \"X\" : ( 0.5 , 1.5 )} for syndrome_graph_key in self . syndrome_graph_keys : # subgraphs for each time step for t in range ( 0 , self . params [ \"T\" ]): start_node = start_nodes [ syndrome_graph_key ] node_label = ( t ,) + start_node self . node_map [ syndrome_graph_key ][ node_label ] = self . S [ syndrome_graph_key ] . add_node ( node_label ) self . _populate_syndrome_graph ( ( t ,) + start_node , t , [], syndrome_graph_key , 1 ) # connect physical qubits in same location across subgraphs of adjacent times syndrome_nodes_t0 = [ ( t , x , y ) for t , x , y in self . S [ syndrome_graph_key ] . nodes () if t == 0 ] for node in syndrome_nodes_t0 : space_label = ( node [ 1 ], node [ 2 ]) for t in range ( 0 , self . params [ \"T\" ] - 1 ): self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][( t ,) + space_label ], self . node_map [ syndrome_graph_key ][( t + 1 ,) + space_label ], 1 , ) def _populate_syndrome_graph ( self , current_node : TQubit , t : int , visited_nodes : List [ TQubit ], syndrome_graph_key : str , edge_weight : int = 1 , ) -> None : \"\"\"Recursive function to populate syndrome subgraph at time t with syndrome_graph_key X/Z. The current_node is connected to neighboring nodes without revisiting a node. Args: current_node ((t, x, y)): Current syndrome node to be connected with neighboring nodes. t (int): Current time, needed if current_node is a virtual node of the form (-1,i,j) visited_nodes ([(t, x, y),]): List of syndrome nodes which have already been traver. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. edge_weight (float, optional): Weight of edge between two adjacent syndrome nodes. Defaults to 1. Returns: None: function is to traverse the syndrome nodes and connect neighbors \"\"\" visited_nodes . append ( current_node ) neighbors = [] i = current_node [ 1 ] # syndrome node x coordinate j = current_node [ 2 ] # syndrome node y coordinate neighbors . append (( i - 1 , j - 1 )) # up left neighbors . append (( i + 1 , j - 1 )) # down left neighbors . append (( i - 1 , j + 1 )) # up right neighbors . append (( i + 1 , j + 1 )) # down right normal_neighbors = [ n for n in neighbors if self . _valid_syndrome ( n , syndrome_graph_key ) and ( t , n [ 0 ], n [ 1 ]) not in visited_nodes ] # syndrome node neighbors of current_node not already visited virtual_neighbors = [ n for n in neighbors if ( - 1 , n [ 0 ], n [ 1 ]) in self . virtual [ syndrome_graph_key ] and ( - 1 , n [ 0 ], n [ 1 ]) not in visited_nodes ] # virtual node neighbors of current_node not already visited # no neighbors to add edges if not normal_neighbors and not virtual_neighbors : return # add normal/non-virtual neighbors for target in normal_neighbors : target_node = ( t , ) + target # target_node has time t with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add target_node to syndrome subgraph if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and target_node # add virtual neighbors for target in virtual_neighbors : target_node = ( - 1 , ) + target # virtual target_node has time -1 with x and y coordinates from target if target_node not in self . S [ syndrome_graph_key ] . nodes (): # add virtual target_node to syndrome subgraph with # z coordinate (T-1)/2 for nice plotting, # if it doesn't already exist self . node_map [ syndrome_graph_key ][ target_node ] = self . S [ syndrome_graph_key ] . add_node ( target_node ) self . S [ syndrome_graph_key ] . add_edge ( self . node_map [ syndrome_graph_key ][ current_node ], self . node_map [ syndrome_graph_key ][ target_node ], edge_weight , ) # add edge between current_node and virtual target_node # recursively traverse normal neighbors for target in normal_neighbors : self . _populate_syndrome_graph ( ( t ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) # recursively traverse virtual neighbors for target in virtual_neighbors : self . _populate_syndrome_graph ( ( - 1 ,) + target , t , visited_nodes , syndrome_graph_key , 1 ) def _valid_syndrome ( self , node : TQubitLoc , syndrome_graph_key : str ) -> bool : \"\"\" Checks whether a node is a syndrome node under our syndrome_graph_key, which is either X or Z. Args: node ((height, width)): Node in graph. syndrome_graph_key (char): Which X/Z syndrome subgraph these nodes are from. Returns: (bool): whether node is a syndrome node \"\"\" i = node [ 0 ] j = node [ 1 ] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] if syndrome_graph_key == \"Z\" : if i > 0 and i < dh - 1 and j < dw and j > - 1 : return True else : return False elif syndrome_graph_key == \"X\" : if j > 0 and j < dw - 1 and i < dh and i > - 1 : return True else : return False else : raise ValueError ( \"Please enter a valid syndrome_graph_key: X or Z\" ) def _specify_virtual ( self ) -> Dict [ str , List [ TQubit ]]: \"\"\" Define coordinates of Z and X virtual syndrome nodes. Our convention is that Z virtual syndrome nodes are top/bottom and X virtual nodes are left/right. Args: Returns: virtual (dictionary): where virtual[\"X\"] holds a list of tuples specifying virtual X syndrome nodes and equivalently for virtual[\"Z\"] \"\"\" virtual : Dict [ str , List [ TQubit ]] = {} virtual [ \"X\" ] = [] virtual [ \"Z\" ] = [] dh = self . params [ \"d\" ][ constants . DH ] dw = self . params [ \"d\" ][ constants . DW ] for j in range ( 0 , dw , 2 ): # Z virtual nodes virtual [ \"Z\" ] . append (( - 1 , - 0.5 , j - 0.5 )) # top virtual [ \"Z\" ] . append (( - 1 , dh - 0.5 , j + 0.5 )) # bottom for j in range ( 0 , dh , 2 ): # X virtual nodes virtual [ \"X\" ] . append (( - 1 , j + 0.5 , - 0.5 )) # left virtual [ \"X\" ] . append (( - 1 , j - 0.5 , dw - 0.5 )) # right return virtual def _is_crossing_readout_path ( self , match : Tuple [ TQubit , TQubit ], logical_readout_type : str ) -> bool : \"\"\" Helper method that detects whether the match is crossing the readout path. Args: match (Tuple[TQubit, TQubit]): match in MWPM between two nodes logical_readout_type (str): \"X\" or \"Z\" Returns: (bool): whether or not the match is crosing the readout path \"\"\" # TODO Logical Z readout will be performed with data qubits in the top row, # this can be generalized later source , target = match if logical_readout_type == \"Z\" : return ( source [ 0 ] == - 1 and source [ 1 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 1 ] == - 0.5 ) # top elif logical_readout_type == \"X\" : return ( source [ 0 ] == - 1 and source [ 2 ] == - 0.5 ) or ( target [ 0 ] == - 1 and target [ 2 ] == - 0.5 ) # left else : raise ValueError ( \"Please enter a valid logical_readout_type (X/Z).\" )","title":"RotatedDecoder"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type","text":"A single, logical XXZZ surface code qubit. Source code in qtcodes/fitters/rotated_surface.py class XXZZQubit ( RotatedQubit ): \"\"\" A single, logical XXZZ surface code qubit. \"\"\" lattice_type = _XXZZLattice","title":"encoder_type"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type","text":"This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. Source code in qtcodes/fitters/rotated_surface.py class _XXZZLattice ( _RotatedLattice ): \"\"\" This class contains all the lattice geometry specifications regarding the XXZZ (CSS) Rotated Surface Code. \"\"\" stabilizer_shortnames = { \"mx\" : _XXXX , \"mz\" : _ZZZZ } def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier () def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier () def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier () def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier () def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target ) def _readout_x_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-X projection into an ancilla qubit. Uses the left-most column. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"ancilla\" ], self . qregisters [ \"data\" ][ i ]) self . circ . h ( self . qregisters [ \"ancilla\" ]) def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def _readout_z_into_ancilla ( self ) -> None : \"\"\" Convenience method to read-out the logical-Z projection into an ancilla qubit. Uses the top-most row. \"\"\" self . circ . reset ( self . qregisters [ \"ancilla\" ]) for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . cx ( self . qregisters [ \"data\" ][ i ], self . qregisters [ \"ancilla\" ]) def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier () def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier () def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_type"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.cx","text":"Logical CX Gate Parameters: Name Type Description Default control Optional[Qubit] If provided, then this gate will implement a logical x gate on this tqubit conditioned on source None target Optional[Qubit] If provided, then this gate will implement a logical x gate on target conditioned on this tqubit None Source code in qtcodes/fitters/rotated_surface.py def cx ( self , control : Optional [ Qubit ] = None , target : Optional [ Qubit ] = None ): \"\"\" Logical CX Gate Args: control (Optional[Qubit]): If provided, then this gate will implement a logical x gate on this tqubit conditioned on source target (Optional[Qubit]): If provided, then this gate will implement a logical x gate on target conditioned on this tqubit \"\"\" if control : # Taking left-most column for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . cx ( control , self . qregisters [ \"data\" ][ i ]) self . circ . barrier () elif target : self . _readout_z_into_ancilla () # TODO: we may not want to read into the ancilla, # let's try to eliminate this intermediate method, self . circ . cx ( self . qregisters [ \"ancilla\" ], target )","title":"cx()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.lattice_readout_x","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical X readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_x ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout # H|+> = |0>, H|-> = |1> self . circ . h ( self . qregisters [ \"data\" ]) self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_x()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.lattice_readout_z","text":"Readout all data qubits that constitute the lattice. This readout can be used to extract a final round of stabilizer measurments, as well as a logical Z readout. Source code in qtcodes/fitters/rotated_surface.py def lattice_readout_z ( self ) -> None : self . params [ \"num_lattice_readout\" ] += 1 creg_name = ( self . name + \"_lattice_readout_\" + str ( self . params [ \"num_lattice_readout\" ]) ) readout = ClassicalRegister ( self . params [ \"num_data\" ], name = creg_name ,) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout self . circ . measure ( self . qregisters [ \"data\" ], self . cregisters [ creg_name ]) self . circ . barrier ()","title":"lattice_readout_z()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.readout_x","text":"Convenience method to read-out the logical-X projection. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def readout_x ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_x_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_x()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.readout_z","text":"Convenience method to read-out the logical-Z projection. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def readout_z ( self , readout_creg : Optional [ ClassicalRegister ] = None ) -> None : if not readout_creg : self . params [ \"num_readout\" ] += 1 creg_name = self . name + \"_readout_\" + str ( self . params [ \"num_readout\" ]) readout = ClassicalRegister ( 1 , name = creg_name ) self . circ . add_register ( readout ) self . cregisters [ creg_name ] = readout readout_creg = self . cregisters [ creg_name ] self . _readout_z_into_ancilla () self . circ . measure ( self . qregisters [ \"ancilla\" ], readout_creg ) self . circ . barrier ()","title":"readout_z()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.reset_x","text":"Initialize/reset to a logical |x+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_x ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . h ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_x()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.reset_z","text":"Initialize/reset to a logical |z+> state. Source code in qtcodes/fitters/rotated_surface.py def reset_z ( self ) -> None : self . circ . reset ( self . qregisters [ \"data\" ]) self . circ . barrier ()","title":"reset_z()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.x","text":"Logical X operator on the qubit. Uses the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x ( self ) -> None : for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"x()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.x_c_if","text":"Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. Source code in qtcodes/fitters/rotated_surface.py def x_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical X operator on the topological qubit. Defined as the left-most column. \"\"\" for i in range ( 0 , self . params [ \"num_data\" ], self . params [ \"d\" ][ self . W ]): self . circ . x ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"x_c_if()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.z","text":"Logical Z operator on the qubit. Uses the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z ( self ) -> None : for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) self . circ . barrier ()","title":"z()"},{"location":"reference/qtcodes/fitters/rotated_surface/#qtcodes.fitters.rotated_surface.RotatedDecoder.encoder_type.lattice_type.z_c_if","text":"Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. Source code in qtcodes/fitters/rotated_surface.py def z_c_if ( self , classical : ClassicalRegister , val : int ) -> None : \"\"\" Classically conditioned logical Z operator on the topological qubit. Defined as the top-most row. \"\"\" for i in range ( self . params [ \"d\" ][ self . W ]): self . circ . z ( self . qregisters [ \"data\" ][ i ]) . c_if ( classical , val ) self . circ . barrier ()","title":"z_c_if()"},{"location":"reference/qtcodes/tools/","text":"Benchmarking Module for Topological Codes benchmarking benchmarking class for qtcodes TopologicalBenchmark Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], ) logical_error_rate ( self , readout_strings , err_prob = None ) Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count single ( self , physical_error_rate , save_data = True , shots = 2048 ) Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value sweep ( self , physical_error_rates = None , save_data = True , shots = 2048 , deg_weight = True ) Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] sweep_mp ( self , physical_error_rates = None , save_data = True , shots = 2048 ) Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"tools"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking","text":"benchmarking class for qtcodes","title":"benchmarking"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking.TopologicalBenchmark","text":"Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], )","title":"TopologicalBenchmark"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking.TopologicalBenchmark.logical_error_rate","text":"Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count","title":"logical_error_rate()"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking.TopologicalBenchmark.single","text":"Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value","title":"single()"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep","text":"Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ]","title":"sweep()"},{"location":"reference/qtcodes/tools/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep_mp","text":"Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"sweep_mp()"},{"location":"reference/qtcodes/tools/benchmarking/","text":"benchmarking class for qtcodes TopologicalBenchmark Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], ) logical_error_rate ( self , readout_strings , err_prob = None ) Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count single ( self , physical_error_rate , save_data = True , shots = 2048 ) Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value sweep ( self , physical_error_rates = None , save_data = True , shots = 2048 , deg_weight = True ) Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] sweep_mp ( self , physical_error_rates = None , save_data = True , shots = 2048 ) Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"benchmarking"},{"location":"reference/qtcodes/tools/benchmarking/#qtcodes.tools.benchmarking.TopologicalBenchmark","text":"Source code in qtcodes/tools/benchmarking.py class TopologicalBenchmark : def __init__ ( self , decoder , circ : QuantumCircuit , noise_model_func = None , correct_logical_value : int = 0 , ): self . decoder = decoder self . circ = circ self . filename = f \"d_ { self . decoder . params [ 'd' ] } _T_ { self . decoder . params [ 'T' ] } .npz\" self . correct_logical_value = correct_logical_value self . noise_model_func = noise_model_func self . data : Dict [ str , List [ float ]] = { \"physical_error_rates\" : [], \"logical_error_rates\" : [], } def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ] def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value def append_data ( self , physical_error_rate : float , logical_error_rate : float ): try : data = np . load ( self . filename ) physical_error_rates = data [ \"physical_error_rates\" ] logical_error_rates = data [ \"logical_error_rates\" ] except : physical_error_rates = np . array ([]) logical_error_rates = np . array ([]) physical_error_rates = np . append ( physical_error_rates , physical_error_rate ) logical_error_rates = np . append ( logical_error_rates , logical_error_rate ) indxs = np . argsort ( physical_error_rates ) np . savez ( self . filename , d = self . decoder . params [ \"d\" ], T = self . decoder . params [ \"T\" ], physical_error_rates = physical_error_rates [ indxs ], logical_error_rates = logical_error_rates [ indxs ], )","title":"TopologicalBenchmark"},{"location":"reference/qtcodes/tools/benchmarking/#qtcodes.tools.benchmarking.TopologicalBenchmark.logical_error_rate","text":"Parameters: Name Type Description Default readout_strings Dict[str, int] a dictionary of readout strings along with counts required e.g. {\"1 00000000 00000000\" 48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 required err_prob Optional[float] Probability of IID data qubit X/Z flip. Defaults to None. None Returns: Type Description error_rate (float) = (number of unsuccessful logical value predictions) / (total number of predictions ) Source code in qtcodes/tools/benchmarking.py def logical_error_rate ( self , readout_strings : Dict [ str , int ], err_prob : Optional [ float ] = None ) -> float : \"\"\" Args: readout_strings: a dictionary of readout strings along with counts e.g. {\"1 00000000 00000000\":48, \"1 00100000 00100000\":12, ...} in the case of d=3 and T=2 err_prob (Optional[float]): Probability of IID data qubit X/Z flip. Defaults to None. Returns: error_rate (float): = (number of unsuccessful logical value predictions) / (total number of predictions ) \"\"\" total_count = 0.0 total_errors = 0.0 for readout , count in readout_strings . items (): total_count += count predicted_logical_value = self . decoder . correct_readout ( readout , \"Z\" , err_prob = err_prob ) if predicted_logical_value != self . correct_logical_value : total_errors += count return total_errors / total_count","title":"logical_error_rate()"},{"location":"reference/qtcodes/tools/benchmarking/#qtcodes.tools.benchmarking.TopologicalBenchmark.single","text":"Take single error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rate float Single physical error rate required save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def single ( self , physical_error_rate : float , save_data : bool = True , shots : int = 2048 , ): \"\"\" Take single error rates and calculate the associated logical error rate. Args: physical_error_rate (float): Single physical error rate save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate ) print ( \"Done simulating physical_error_rate: \" + str ( physical_error_rate )) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) return logical_error_rate_value","title":"single()"},{"location":"reference/qtcodes/tools/benchmarking/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep","text":"Sweep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 deg_weight bool Whether or not to use degeneracy weighting. True Source code in qtcodes/tools/benchmarking.py def sweep ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , deg_weight : bool = True , ) -> None : \"\"\" Sweep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. deg_weight (bool): Whether or not to use degeneracy weighting. \"\"\" self . data [ \"physical_error_rates\" ] = [] self . data [ \"logical_error_rates\" ] = [] physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], reverse = True , ) # higher physical_error_rate readout is slower to decode, gives more accurate tqdm estimate pbar = tqdm ( physical_error_rates ) for physical_error_rate in pbar : results = ( execute ( self . circ , Aer . get_backend ( \"aer_simulator\" ), noise_model = self . noise_model_func ( physical_error_rate ), optimization_level = 0 , shots = shots , ) . result () . get_counts () ) logical_error_rate_value = self . logical_error_rate ( results , err_prob = physical_error_rate if deg_weight else None ) self . data [ \"physical_error_rates\" ] . append ( physical_error_rate ) self . data [ \"logical_error_rates\" ] . append ( logical_error_rate_value ) if save_data : self . append_data ( physical_error_rate , logical_error_rate_value ) pbar . set_description ( f \"Done with noise: { physical_error_rate } \" ) # final sort physical_error_rates_final = np . array ( self . data [ \"physical_error_rates\" ]) logical_error_rates_final = np . array ( self . data [ \"logical_error_rates\" ]) indxs = np . argsort ( physical_error_rates_final ) self . data [ \"physical_error_rates\" ] = physical_error_rates_final [ indxs ] self . data [ \"logical_error_rates\" ] = logical_error_rates_final [ indxs ]","title":"sweep()"},{"location":"reference/qtcodes/tools/benchmarking/#qtcodes.tools.benchmarking.TopologicalBenchmark.sweep_mp","text":"Multi-processed weep physical error rates and calculate the associated logical error rate. Parameters: Name Type Description Default physical_error_rates Optional[List[float]] List of physical error rates to sweep. None save_data bool This boolean determines whether this data is saved to an npz file. True shots int Shots in the circuit simulation. 2048 Source code in qtcodes/tools/benchmarking.py def sweep_mp ( self , physical_error_rates : Optional [ List [ float ]] = None , save_data : bool = True , shots : int = 2048 , ) -> None : \"\"\" Multi-processed weep physical error rates and calculate the associated logical error rate. Args: physical_error_rates (Optional[List[float]]): List of physical error rates to sweep. save_data (bool): This boolean determines whether this data is saved to an npz file. shots (int): Shots in the circuit simulation. \"\"\" physical_error_rates = sorted ( physical_error_rates if physical_error_rates is not None else [ 0.04 , 0.07 , 0.10 , 0.13 , 0.16 ,], ) p = Pool ( 4 ) # TODO change on HPC single_lambda = lambda physical_error_rate : self . single ( physical_error_rate , save_data = save_data , shots = shots ) logical_error_rates = p . map ( single_lambda , physical_error_rates ) self . data [ \"physical_error_rates\" ] = physical_error_rates self . data [ \"logical_error_rates\" ] = logical_error_rates","title":"sweep_mp()"}]}